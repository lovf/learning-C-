//90-C++: 内存管理 00:45

//栈: 局部变量
//堆: 动态开辟的空间
//数据段: 静态变量或者全局变量
//代码段: 二进制可执行代码/只读常量

//数组名: 数组首元素地址
//   特殊: sizeof, &数组名---->整个数组
//sizeof: 类型的大小
//strlen: 字符串有效字符的个数,看\0结束的位置

//C语言中动态内存管理方式:
//*****************************************************************************************
//面试常考:  C语言中malloc/calloc/realloc之间的区别
//*****************************************************************************************


// malloc/calloc/realloc/free
// malloc: 用于申请空间,申请空间的值是随机值
//#include <stdio.h>
//#include <stdlib.h>
//
//void test1() {
//
//	// malloc: 只申请空间, 不进行初始化
//	int* pa = (int*)malloc(sizeof(int));
//	*pa = 10;
//	int num = 2;
//	//calloc: 申请空间 +0的初始化
//	//calloc(开几个元素, 每一个元素占几个空间)
//	int* pb = (int*)calloc(num, sizeof(int));
//
//	//realloc: 重新申请空间
//	//realloc(调整空间的首地址, 需要调整的大小);
//	//realloc: 如果原有空间有内容, 则把内容拷贝到新的空间中
//	//realloc:
//	//具体执行步骤: realloc使用时最终只需要释放realloc返回之后的数值即可, 不需要释放传入realloc中的值(如果释放会引起二次释放问题)
//	//第一种情况: 1.重新开空间 2. 拷贝原有内容 3. 释放原有空间
//	//第二种情况: 申请新的空间(修改头信息)不会释放原有空间
//	//第三种情况: 减小空间大小(修改头信息)不会释放原有空间
//	//第四种情况: realloc(nullptr, 字节数); 功能等价于malloc
//	int* pc = (int*)realloc(pa, sizeof(int)*100);
//
//	printf("%d\n", *pa);  //随机值
//	printf("%d\n", *pb);  //0
//	printf("%d\n", *pc); //10
//	free(pb);
//	free(pc);
//	//free(pa); //出现错误;出现二次释放的问题
//}
//
//void test2() {
//	// 1 byte
//	char* pa = (char*)malloc(sizeof(char));
//	*pa = 'a';
//	//第二种逻辑: 申请新的空间(修改头信息)不会释放原有空间
//	// 2 byte
//	int* pc = (int*)realloc(pa, sizeof(char)* 2);
//	//第三种逻辑: 减小空间大小(修改头信息)不会释放原有空间
//	// 1 byte
//	char* pd = (char*)realloc(pc, sizeof(char));
//	//第四种情况: realloc(nullptr, 字节数); 功能等价于malloc
//	char* pe = (char*)realloc(nullptr, sizeof(char));
//}
//
//int main() {
//	test2();
//	test2();
//	system("pause");
//	return 0;
//}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//C++中内存管理方式: 通过new和delete操作符进行动态内存管理
//#include <iostream>
//#include <stdio.h>
//#include <stdlib.h>
//using namespace std;
//
//class Date{
//public:
//	Date(){
//		cout << "Date" << endl;
//	}
//	Date(int y, int m,int d) 
//		:_year(y)
//		, _month(m)
//		, _day(d)
//	{}
//	Date(int y)
//		:_year(y)
//	{}
//	~Date() {
//	
//		cout << "~Date()" << endl;
//	}
//private:
//	int _year = 1900;
//	int _month = 1;
//	int _day = 1;
//};
//
//void test1() {
//	//用malloc动态申请自定义类型的对象时: 对象的内容为随机值, malloc不负责初始化
//	//malloc不能调用自定义类型的构造函数
//	Date* pd = (Date*)malloc(sizeof(Date)); //malloc不会自动调用默认构造函数
//    
//	//开辟自定义类型的空间
//	//完成了类型的初始化
//	Date* pd1 = new Date; //自动调用类的默认构造函数完成初始化--->调用默认构造
//	Date* pd2 = new Date(2020, 10, 25); //掉构造完成初始化--->调用三个参数
//	Date* pd3 = new Date(2020); //调用单参构造,剩下的两个为默认缺省
//	//在堆上构建自定义类型的数据, new只能调用默认构造
//	//new: 开空间 ---->构造(如果是数组的话, 那么调用多个构造函数)
//	Date* pd4 = new Date[10]; 
//	cout << "delete" << endl;
//
//	free(pd);// 不会调用析构函数
//	//delete pd: 要申请和释放的对应使用;  new: 动态开辟空间, delete: 释放空间  malloc : 申请空间  free: 进行资源释放
//	//delete: 调用一次析构
//	//delete[]: 调用多次析构
//	//析构释放对象当中的数据资源
//	delete pd1;
//	delete pd2;
//	delete pd3;
//	delete[] pd4;
//	//new: 开空间 ---->构造
//	//delete: 析构 ---->释放空间
//}
//
//void test2() {
//
//	//malloc不会调用构造函数, free不会调用析构函数
//	//在堆上申请4个byte空间
//	//申请一个元素空间
//	int* pa = (int*)malloc(sizeof(int));
//	int* pa2 = new int; 
//	//在堆上申请连续的空间
//	int* pb = (int*)malloc(sizeof(int));
//	int* pb2 = new int[10]; //申请连续的空间
//	//在堆上申请空间 + 初始化
//	//*pc: 20
//	int* pc = new int(20);
//	//释放一个元素空间
//	free(pa);
//	delete pa2; 
//	//释放连续空间
//	free(pb);
//	delete[] pb2;
//}
//
////new/delete:
////new: 动态开辟空间, delete: 释放空间
////new--->delete  new[]---->delete[]  ------>对应使用;   假如不对应使用,对应自定义类型影响比较大,内置类型影响倒是不那么大
////new 类型[表示元素个数]   new 类型(表示元素初始值)
//
//int main() {
//	test1();
//	//test2();
//	system("pause");
//	return 0;
//}
/////////////////////////////////////////////
/////////////////////////////////////////////
//////////////////////////////////
///////////////////////
开辟自定义类型的空间
#include <stdio.h>
#include <stdlib.h>

class Date{
public:
	Date(int y = 1900, int m = 1, int d = 1)
		:_year(y)
		, _month(m)
		, _day(d)
	{}

private:
	int _year = 1900;
	int _month = 1;
	int _day = 1;
};

void test1() {
	//用malloc动态申请自定义类型的对象时: 对象的内容为随机值, malloc不负责初始化
	//malloc不能调用自定义类型的构造函数
	Date* pd = (Date*)malloc(sizeof(Date));
}
void test2() {
	//在堆上申请4个byte空间
	//申请一个元素空间
	int* pa = (int*)malloc(sizeof(int));
	int* pa2 = new int;
	//在堆上申请连续的空间
	int* pb = (int*)malloc(sizeof(int));
	int* pb2 = new int[10]; //申请连续的空间
	//在堆上申请空间 + 初始化
	//*pc: 20
	int* pc = new int(20);
	//释放一个元素空间
	free(pa);
	delete pa2;
	//释放连续空间
	free(pb);
	delete[] pb2;
}
//new/delete:
//new: 动态开辟空间, delete: 释放空间
//new--->delete  new[]---->delete[]  ------>对应使用;   假如不对应使用,对应自定义类型影响比较大,内置类型影响倒是不那么大
//new 类型[表示元素个数]   new 类型(表示元素初始值)

int main() {
	test1();

	test2();
	system("pause");
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// operator new/operator delete
//******************************************
//void* operator new(size_t size)
//operator new不是new的运算符重载函数
//void* operator new(size_t size) 

//operator new使用方式类似于malloc
//  1.内部通过malloc申请空间
//  2.如果malloc空间申请失败:
//     a:设置空间不足的应用措施, 则执行执行完之后继续调用malloc再次申请空间, 直到空间申请成功
//     b:如果没有设置空间不足的应用措施, 直接抛异常(没有内存的异常)
//malloc: 申请空间成功,返回有效地址; 申请空间失败,返回指针空值
//operator new: malloc + 异常
//假如存在异常可以通过: 
//try{
//	char* pc3 = (char*) operator new(0x7fffffff); //存在异常的代码
//}
//catch (exception& e) {
//	cout << e.what() << endl; //能够查看存在异常的原因
//}
//*****************************************
//operator delete: 封装free, 不会抛异常(最终通过free释放空间)
//*****************************************
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//new ----> operator new ---->malloc ---->构造函数
//new和delete的实现原理:
//1.内置类型
//   如果申请的是内置类型的空间, new和malloc, delete和free基本类似, 不同的地方是: new/delete申请和释放的是单个元素的空间, 
//new[]/delete[]申请的是连续的空间,而且new申请空间失败时会抛异常(异常是通过operator new 释放出来的), malloc会返回NULL(指针空值);
//2.自定义类型
// new的原理:
//   1.调用operator new申请空间   2.在申请的空间上执行构造函数, 完成对象的构造
// delete原理:
//   1.在空间上执行析构函数, 完成对象中资源的清理工作  2.调用operator delete 完成释放对象的空间
//new T[N]原理:
//   1.调用operator new[]函数, 在operator new[]中实际调用operator new函数完成对N个对象空间的申请  2.在申请的空间上执行N次构造函数
//delete[]的原理:
//   1.在释放的对象空间上执行对此的析构函数, 完成N个对象中资源的清理  2.调用operator delete[]中的operator delete来释放空间
//7.常见面试题
//7.1 malloc / free和new / delete的区别
//malloc / free和new / delete的共同点是：都是从堆上申请空间，并且需要用户手动释放。不同的地方是：
//1. malloc和free是函数，new和delete是操作符
//2. malloc申请的空间不会初始化，new可以初始化
//3. malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可
//4. malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型
//5. malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常
//6. 申请自定义类型对象时，malloc / free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间
//后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理
//
//7.2 内存泄漏-----内存一直被借用一直没有被还回来
//7.2.1 什么是内存泄漏，内存泄漏的危害
//内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，
//因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。
//内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢, 最终卡死.

//7.2.2 内存泄漏分类（了解）
//C / C++程序中一般我们关心两种方面的内存泄漏：
//堆内存泄漏(Heap leak)：
//堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存，用完后必须通过调用相应的 free或者delete 删掉。
//假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生Heap Leak。
//系统资源泄漏：
//指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。

//7.2.3 如何检测内存泄漏（了解）----valgring(程序检测工具)
//
//在linux下内存泄漏检测：linux下几款内存泄漏检测工具
//在windows下使用第三方工具：VLD工具说明
//其他工具：内存泄漏工具比较

//7.2.4如何避免内存泄漏---------大型程序借助检测工具来实现
//1. 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。
//2. 采用RAII思想或者智能指针来管理资源。
//3. 有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。
//4. 出问题了使用内存泄漏工具检测。
//总结一下 :
//内存泄漏非常常见，解决方案分为两种：1、事前预防型。如智能指针等。2、事后查错型。如泄漏检测工
//具。
//面试题：如何在堆上一次性申请4G的内存？
//32位程序是得不到的;  如果是64位程序是可以拿得到的
