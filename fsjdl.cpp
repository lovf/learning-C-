-------------------------------------继承-----------------------------------------
#include <string>
#include <iostream>
using namespace std;

class Person{
public:
	void Print() {
		cout << "name: " << _name << endl;
		cout << "age:" << _age << endl;
	}
	
	//protected:类外不可见，在类内部和子类中可见
	//一般在这块父类成员都是定义成protected成员的，因为让父类可以继承它
protected:
	string _name = "peter";//姓名
	int _age = 18;//年龄
private:
	int _id = 2;
};

//继承： 类代码复用-------Person中的成员就变成Student的一部分。
//学生当中的成员是包含_name和_age的
//class/struct 类名： 需要继承的类
//       子类/派生类：父类/基类  

class Student:public Person {  //public:表示公有继承   等价于  struct Student: Person (默认继承方式公有继承) 通常情况下--都是写公有继承
//class Student :protected Person { //表示保护继承 -------在子类中可见,再类外不可见
//class Student :private Person {//表示私有继承   等价于  class Student : Person(默认继承方式私有继承)-----基类的私有成员在子类中不可见
//------一般继承使用方式:公有继承 
//私有成员-------不可见的  特殊一点点

public:
	void setId() {
		//基类的私有成员不可见,但是确实继承下来了,可以通过sizeof进行查看
		//_id = 10;
	}
	void setName() {
		//保护成员在子类中可见,再类外不可见
		_name = "peter1";
		_age = 18;
	}

protected:
	int _stuid; //学号
};

class Teacher :public Person {  //public:表示公有继承   等价于  struct Student: Person (默认继承方式公有继承)
	
protected:
	int _jobid; //工号

};
class Empty
{};

void test() {
	Teacher t;
	Person s;
	t.Print();
	s.Print();

	cout << sizeof(Person) << endl; //基类私有成员在子类中不可见,但是确实继承下来了,通过sizeof可以进行查看
	cout << sizeof(Student) << endl;
	cout << sizeof(Empty) << endl;

}

int main() {

	test();
	system("color A");
	system("pause");
	return 0;
}

///////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//*************************有关切片行为的操作--同名隐藏--函数重载***************************************
#include <string>
#include <iostream>
using namespace std;

class Person{
public:
	void Print() {
		cout << "name: " << _name << endl;
		cout << "age:" << _age << endl;
		cout << "id:" << _id << endl;
	}
	void func() {
		cout << "Person::func()" << endl;
	}
	//protected:类外不可见，在类内部和子类中可见
	//一般在这块父类成员都是定义成protected成员的，因为让父类可以继承它
protected:
	string _name = "peter";//姓名
	int _age = 18;//年龄
//private:
	int _id = 2;
};

class Student:public Person {  //public:表示公有继承   等价于  struct Student: Person (默认继承方式公有继承) 通常情况下--都是写公有继承
public:
	void setId() {
		//基类的私有成员不可见,但是确实继承下来了,可以通过sizeof进行查看
		//设置子类中的id
	
		_id = 10;
		//成员变量的同名隐藏:
		//父类中的id会被同名隐藏
		//如果需要访问父类中的同名成员变量,需要在前面加上作用域
		//Person::_id = 100;//是父类中的id发生改变
		cout << "id:" << _id << endl;//默认修改的是子类的id变化,打印子类中定义的id
	}
	void setName() {
		//保护成员在子类中可见,再类外不可见
		_name = "peter1";
		_age = 18;
	}
	void func() {
	
		cout << "Student::func()" << endl;
	}

//protected:
	int _stuid = 2020; //学号
	int _id = 1;//子类也可以设置和父类相同的变量名,因为两个是属于不同的作用域
};


void test1() {
	int a = 2.5;//隐式类型转化
	Student s;
	Person p;
	
	//切片操作-----------把属于父类的那一部分切片过去给子类,并不是隐式类型的转化,也不是强转
	//切片:子类--->父类(向上转型)  父类--->子类(向下转型)
	//能把大的往小的,小的不能往大的转化---------------------形象的描述了切片的操作
	// 1.子类对象可以赋值给父类对象/指针/引用
	p = s;//等于是把父类的赋值给子类
	Person* ptr = &s;//(Person*)父类型的指针-----只能访问父类型大小的成员
	Person& ref = s;
	s.Print();
	s.setId();
	//子类转父类存在非法行为不安全.
	//父类对象不能转为子类对象,因为有可能子类的成员大于父类的成员,但是如果把父类的赋值给子类的那么就只是赋值父类的部分,不会存在不够的情况
	//s = p; 反过来根本不行-----不能把一个小的区域切片给一个大片,只能将父类中转化给子类中
	//Student* ptr2 = &p;
	//强制类型转换:不安全,访问不到子类中新增的成员
	//Student* ptr2 = (Student*)&p;
	//Student& ref2 = p;
	//Student& ref2 = (Student&)p;
}

void test2() {

	Student s;
	//子类和父类都有相同的成员变量------------产生成员变量的同名隐藏,默认都是访问当前作用域的,假如需要调用父类的需要加上作用域
	s.setId();//子类作用域中的id---改变子类作用域中的id存在同名隐藏
	s.Print();//属于父类中的id---
	//子类和父类都有相同的成员函数------------产生成员函数同名隐藏,默认都是访问当前作用域的,假如需要调用父类的需要加上作用域
	s.func();//默认都是访问当前作用域的
	//调用父类的:
	s.Person::func();//假如需要调用父类的需要加上作用域

}
int main() {
	
	//test1();
	test2();
	system("pause");
	return 0;
}
********************************同名隐藏和函数重载的区别******************************************
1.同名隐藏:分为同名函数隐藏和同名参数隐藏---------只要函数名相同或者变量相同就可以构成同名隐藏,不管参数相同不相同
2.函数隐藏-------同名函数位于两个不同的作用域中，一个位于父类中，一个位于子类中
3.成员函数:只要函数名相同就可以构成同名隐藏,此时为了避免就要加上父类的作用域
4.函数重载:函数名相同,参数不同就会构成函数重载,,前提是在同一个作用域中
总结: 根据函数对应的参数以及作用域可进行区分

在子类中尽量不要定义同名的成员,不然很容易构成同名隐藏----


//*************************************成员函数分别在子类和父类中的关系：++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
///////////////////////////////////////////////////////////////////////////////////////////
//
#include <string>
#include <iostream>
using namespace std;

class  A{
public:
	//构造函数
	A(int a)
		:_a(a)
	{
		cout << "A(int)" << endl;
	}

	A() {
		cout << "A()" << endl;
	}
	//拷贝构造
	A(const A& a){
		cout << "A(const A& a)" << endl;
	}
	//赋值运算符
	A& operator=(const A& a) {
		cout << "operator=(const A& a)" << endl;
		return *this;
	}
	~A() {
		cout << "~A" << endl;
	}

private:
	int _a;
};
class B :public A{
public:

	//父类构造在子类初始化列表处自动调用
	//先执行父类的构造函数,在执行子类构造函数的函数体

	//如果父类中没有默认构造,需要显示指定

	//
	B() 
		:A(2)//显示指定
	{
		cout << "B()" << endl;
	}
	//继承的父类成员必须完成调用父类构造完成初始化,不能在子类构造中进行初始化
	B(int a,int b)
		:A(a)//:_a(a)
		, _b(b)
	{}
	//拷贝构造
	B(const B& b) 
		:A(b)//显示指定---执行父类的拷贝构造
	{
		cout << "B(const A& a)" << endl;
	}

	B& operator=(const B& b) {
		//子类的operator=和父类的operator=构成同名隐藏
		//A::operator=(b);//等于指定调用父类的拷贝构造函数
		cout << "operator=(const B& b)" << endl;
		return *this;
	}
	//底层编译之后,子类析构和父类析构函数名相同,构成同名隐藏
	~B() {
		//A::~A();//指定调用A的析构,这块不用指定调用父类的析构,因为无论写与不写父类的析构都会被调用,假如写了可能会导致二次释放的问题
		cout << "~B" << endl;
	}
private:
	int _b;
};

//void test1() {
//	B b;//创建子类对象时,会自动调用父类的默认构造----调用构造
//	//没显示定义子类的拷贝构造:执行拷贝对象时:子类默认的拷贝构造自动调用父类的拷贝构造,在执行B的拷贝构造体--
//	//显示定义了子类的拷贝构造函数: 执行拷贝对象时子类的拷贝构造自动调用父类的拷贝构造函数,在执行B的拷贝构造体------
//	B b2 = b;//创建对象----默认情况----调用B拷贝构造  -----在初始化列表处先执行A的构造,在执行B的拷贝构造体
//}

void test2() {
	//B b1(1, 2);
	//B b2(3, 4);
	////默认情况(没有显示写子类的赋值运算符)----自动调用父类的赋值运算符
	////显示定义的子类赋值运算符不会调用父类的赋值运算符,只调用子类的赋值运算符
	////假如需要调用父类的拷贝构造函数需要----A::operator=(b)---这样一些才会调用父类的拷贝构造函数
	//b2 = b1;

	//A::~A();//指定调用A的析构,这块不用显示调用父类的析构,因为无论写与不写都会调用父类的析构,假如写了最终会导致父类析构被调用二次,导致二次释放的问题
	//默认情况下子类的析构会自动调用父类的析构函数
	//B b3;
	B b4;

}

int main() {
	
	test2();
	
	//test1();
	system("pause");
	return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//继承与友元++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//有缘关系不能传递





//继承与静态成员+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//继承下面都共享这个静态成员
#include<string>
#include <iostream>
using namespace std;

class A{
public:
	static int _i;
};

int A::_i = 10;

class B :public A{

};
class C :public B{

};  

void test1() {
	A a;
	B b;
	C c;
	int* ptr = &a._i; //这块都访问的是都是一个成员
	ptr = &b._i;
	ptr = &c._i;
}

int main() {
	test1();

	system("pause");
	return 0;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


多继承问题=++++面试中常考=============================================================================
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

继承=====类代码的复用======面试中常考菱形继承
菱形继承===========
公共的基类成员会存在两份:数据冗余  
公共的基类成员会有二义性
如何解决? 给公共继承的前面添加virtual(添加到公共继承的部分)   //虚基表指针----用于解决数据冗余/二义性的问题
虚基表也可以进行切片操作============
虚基表偏移量找到公共成员============
#include<string>
#include <iostream>
using namespace std;


class A{ //公共的类
public: 
	 int _a;
};

class B :virtual public A{  // B继承A   多继承==============================
public:
	int _b;
};


class C :virtual public A{//C继承A       
public:
	int _c;
};

class D :public B, public C{  //D又继承上面两个类
public:
	int _d;
};

void test1() {
	D d;
	d._a = 1;//必须指明那个作用域下的a
	d._a = 1;//有了虚基表就可以进行直接访问
	d.B::_a = 1;
	d._b = 2;
	d.C::_c = 3;
	d._c = 4;
	d._d = 5;
}
int main() {
	test1();

	system("pause");
	return 0;
}

8.继承的总结和反思
1.很多人说C++语法复杂，其实多继承就是一个体现。有了多继承，就存在菱形继承，有了菱形继承就有
菱形虚拟继承，底层实现就很复杂。所以一般不建议设计出多继承，一定不要设计出菱形继承。否则在
复杂度及性能上都有问题。
2.多继承可以认为是C++的缺陷之一，很多后来的OO语言都没有多继承，如Java。
3.继承和组合
public继承是一种is - a的关系。也就是说每个派生类对象都是一个基类对象。
组合是一种has - a的关系。假设B组合了A，每个B对象中都有一个A对象。
优先使用对象组合，而不是类继承 。
继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用
(white - box reuse)。术语“白箱”是相对可视性而言：在继承方式中，基类的内部细节对子类可见 。
继承一定程度破坏了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关
系很强，耦合度高。
对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对
象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black - box reuse)，
因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。 组合类之间没有很强的依赖关系，
耦合度低。优先使用对象组合有助于你保持每个类被封装。
实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适
合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就
用组合

