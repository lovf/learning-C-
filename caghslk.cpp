////2.栈的压入、弹出序列
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。
例如，序列{ 1, 2, 3, 4, 5 } 是某栈的压栈序列，序列{ 4, 5, 3, 2, 1 } 是该压栈序列对应的一个弹出序列，但{ 4, 3, 5, 1, 2 } 就不可能是该压栈序列的弹出序列。
/////////////////////////////////////////////////////////////////////////////////////////////////////
示例 1：
输入：pushed = [1, 2, 3, 4, 5], popped = [4, 5, 3, 2, 1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
示例 2：
输入：pushed = [1, 2, 3, 4, 5], popped = [4, 3, 5, 1, 2]
输出：false
解释：1 不能在 2 之前弹出。

解题思路 :
按照popped的出栈顺序模拟一下, 出栈操作.
使用一个栈st 来模拟此操作.将pushed数组中的每一个元素依次入栈, 出栈时判定st的顶部元素是不是popped数组的当前元素,
如果是就一直循环即可, 最后检查栈是不是空栈

算法 : 初始化栈
	 遍历pushed中的所有元素, 依次进行入栈操作
	 检查栈顶元素是否与popped元素相等.(既满足出栈的条件)
	 栈内是否为空即可
	 ///////////////////////////////////////////////////////////////////////////////////////////////////////
class Solution {
public:
	bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
		stack<int>st;
		int pushIdx = 0;
		int popIdx = 0;
		while (pushIdx < pushed.size()) {
			//入栈
			st.push(pushed[pushIdx]);
			pushIdx++;
			//判断是否出栈
			while (!st.empty() && st.top() == popped[popIdx]) {
				//出栈
				st.pop();
				popIdx++;
			}
		}
		return st.empty();
	}
};

