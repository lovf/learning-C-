//类的大小计算:
//一个类的大小实际就是该类中各个"成员变量"之和
//遵循结构体内存对齐原则:
//1.第一个成员是起始位置.
//2.其他成员要对应到某个数(对齐数)的整数倍的地址上.对齐数=编译器默认的一个对齐数(一般是8)与该成员大小的较小值.
//3.结构体总的大小为:最大对齐数的整数倍的位置上.
//4.如果嵌套了结构体的话,嵌套的结构体对其到自己最大对齐数的整数倍的位置上,结构体的整体大小也是最爱对齐数的整数倍.
//(嵌套的结构体自身也要遵循结构体内存对齐原则)
//修改编译器默认的对齐数:#Pragma pack()
//特殊说明;
//光有新的函数成员定义,但是没有给新的类定义一个成员变量,那么这块字节为0;本身单独一个类的定义是不占内存空间的.
//空类比较特殊大小占一个字节.
//类大小计算举例:
//#include <iostream>
//using namespace std;
//
//
//class C {
//	int _c;
//};
//
//class D{
//	int _c;
//	void fun1() {
//		int a = 1;
//		float b = 2.0;
//		char c= 'a';
//	}//光有新的函数成员定义,但是没有给新的类定义一个成员变量,那么这块字节为0;本身单独一个类的定义是不占内存空间的.
//};
//
//class E {
//	void fun1() {
//		int a = 1;
//		float b = 2.0;
//		char c = 'a';
//	}
//
//};
//
//class F {
//
//};
//
//
//void test() {
//
//	cout << sizeof(C)<< " " << sizeof(D)<< " " << sizeof(E)<< " " << sizeof(F)<< " " << endl;
//}
//
//int main() {
//
//	test();
//	system("pause");
//	return 0;
//}
//***********************************************************************************************************
//#include <iostream>
//using namespace std;

//class D{
//	int _c;
//	class C {
//		int _c;
//	};
//	C h;
//	//光有新的函数成员定义,但是没有给新的类定义一个成员变量,那么这块字节为0;本身单独一个类的定义是不占内存空间的.
//	//这块直接给新的类定义了一个变量,那么就要遵循嵌套原则;
//};
//
//void test() {
//
//	cout << sizeof(D) <<  endl;//8
//}
//
//int main() {
//
//	test();
//	system("pause");
//	return 0;
//}
//如何知道结构体某个成员相对于起始位置的偏移量?
//结构体成员变量的指针 - 起始位置成员变量的指针
#include <iostream>
using namespace std;

struct I{

	char _a;
	int _b;
	float _c;
	char _d;
};
void test() {

	I os;
	cout << (char*)&os._d - (char*)&os << endl;//12
} 
int main() {

	test();
	system("pause");
	return 0;
}








